"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const reconcilerState_1 = tslib_1.__importDefault(require("../reconcilerState"));
const types_1 = require("../types");
const getCurrentHookAndIncrementIndex = (wipFiber, value) => {
    const currentHookIndex = wipFiber.currentHookIndex;
    const componentKey = wipFiber.key;
    wipFiber.currentHookIndex++;
    // set value of hook in fiber so that it can be included in state
    wipFiber.hooks[currentHookIndex] = { type: 'action', value };
    return [
        value,
        payload => {
            reconcilerState_1.default.enqueueSideEffectIfEnabled({
                type: 'action',
                hookIndex: currentHookIndex,
                componentKey,
                payload,
            });
        },
    ];
};
const getHookValueResolver = (wipFiber, value) => {
    const currentHookIndex = wipFiber.currentHookIndex;
    wipFiber.currentHookIndex = 0;
    return Promise.resolve(value).then(value => {
        reconcilerState_1.default.disableSideEffectsQueue();
        if (!wipFiber) {
            throw new Error('cannot resolve useAction');
        }
        wipFiber.hooks[currentHookIndex] = { type: 'action', value };
    });
};
const processInitialValueAndThrow = (wipFiber, initialValue) => {
    // Don't clear the queue here, just enable it, as there may be multiple initialValue functions/promises that call dispatch.
    reconcilerState_1.default.enableSideEffectsQueue();
    // calculate the value of the hook and reset index
    const value = initialValue instanceof Function ? initialValue() : initialValue;
    const hookValueResolver = getHookValueResolver(wipFiber, value);
    wipFiber.currentHookIndex = 0;
    throw hookValueResolver;
};
exports.useAction = (actionValueUpdater, initialValue) => {
    const { wipFiber, currentEffect } = reconcilerState_1.default;
    const { hooks, currentHookIndex } = wipFiber;
    if (hooks[currentHookIndex]) {
        const { value } = hooks[currentHookIndex];
        return getCurrentHookAndIncrementIndex(wipFiber, value);
    }
    const previousState = reconcilerState_1.default.previousState;
    const componentKey = wipFiber.key;
    if (types_1.isInitializeEffect(currentEffect) || !previousState[componentKey]) {
        processInitialValueAndThrow(wipFiber, initialValue);
    }
    else {
        const previousValue = previousState[componentKey][currentHookIndex];
        if (types_1.isActionEffect(currentEffect) &&
            currentEffect.componentKey === componentKey &&
            currentEffect.hookIndex === currentHookIndex) {
            reconcilerState_1.default.enableSideEffectsQueue();
            // if the action refers to this hook, run previous state through action value updater
            const value = actionValueUpdater(previousValue, currentEffect.payload);
            throw getHookValueResolver(wipFiber, value);
        }
        return getCurrentHookAndIncrementIndex(wipFiber, previousValue);
    }
    throw new Error('invalid effect');
};

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const reconcilerState_1 = tslib_1.__importDefault(require("./reconcilerState"));
const reconcile_1 = require("./reconcile");
const context_1 = require("./context");
exports.render = (elem) => async (payload, runtimeContext) => {
    try {
        reconcilerState_1.default.config = payload.config;
        reconcilerState_1.default.previousState = payload.state;
        reconcilerState_1.default.productContext = context_1.toProductContext(payload.context, runtimeContext);
        let latestRenderEffect;
        const effects = [...payload.effects];
        while (effects.length !== 0) {
            const effect = effects.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion
            switch (effect.type) {
                case 'initialize':
                case 'action':
                    reconcilerState_1.default.disableSideEffectsQueue();
                    reconcilerState_1.default.clearSideEffectsQueue();
                    reconcilerState_1.default.currentEffect = effect;
                    const fiber = await reconcile_1.processAuxElement(elem);
                    const renderEffect = {
                        type: 'render',
                        aux: { type: 'View', children: reconcile_1.getAuxFromFiber(fiber) },
                        state: reconcile_1.getStateFromFiber(fiber),
                    };
                    // If there are any new effects in queuedSideEffects, it means they must have been invoked from within another action.
                    // So push these into the effects queue for processing
                    effects.push(...reconcilerState_1.default.queuedSideEffects);
                    reconcilerState_1.default.previousState = renderEffect.state;
                    latestRenderEffect = renderEffect;
                    break;
                case 'event':
                    reconcilerState_1.default.disableSideEffectsQueue();
                    reconcilerState_1.default.clearSideEffectsQueue();
                    reconcilerState_1.default.currentEffect = effect;
                    await reconcile_1.processAuxElement(elem);
                    effects.push(...reconcilerState_1.default.queuedSideEffects);
                    break;
                default:
                    throw new Error(`Invalid effect: ${JSON.stringify(effect)}`);
            }
        }
        return latestRenderEffect ? [latestRenderEffect] : [];
    }
    catch (error) {
        console.log(error);
        throw error;
    }
};

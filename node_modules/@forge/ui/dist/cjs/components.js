"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/** @jsx ForgeUI.createElement */
const _1 = tslib_1.__importStar(require("./"));
const types_1 = require("./types");
const _2 = require("./");
exports.Button = 'Button';
exports.ButtonSet = 'ButtonSet';
exports.Text = 'Text';
exports.Image = 'Image';
exports.Checkbox = 'Checkbox';
exports.CheckboxGroup = 'CheckboxGroup';
exports.DatePicker = 'DatePicker';
exports.ErrorPanel = 'ErrorPanel';
exports.Fragment = 'Fragment';
exports.Cell = 'Cell';
exports.Head = 'Head';
exports.Row = 'Row';
exports.Table = 'Table';
exports.Form = 'Form';
exports.TextArea = 'TextArea';
exports.TextField = 'TextField';
exports.Option = 'Option';
exports.UserPicker = 'UserPicker';
exports.Select = 'Select';
exports.ThreeLOPrompt = 'ThreeLOPrompt';
exports.Radio = 'Radio';
exports.RadioGroup = 'RadioGroup';
const ConfigFormPrimitive = 'ConfigForm';
const childrenMap = (children, fn) => {
    if (Array.isArray(children)) {
        return children.map(child => !Array.isArray(child) && types_1.isForgeElement(child) ? fn(child) : child);
    }
    return types_1.isForgeElement(children) ? fn(children) : children;
};
exports.ConfigForm = (props) => {
    const config = _1.useConfig() || {};
    const setConfigValues = (elems) => childrenMap(elems, (child) => {
        if (child.type === exports.Select &&
            Object.keys(config).includes(child.props.name)) {
            return {
                ...child,
                props: {
                    ...child.props,
                    children: childrenMap(child.props.children, option => 
                    // This is required as we need to handle single and multi select components
                    []
                        .concat(config[child.props.name] || [])
                        .includes(option.props.value)
                        ? {
                            ...option,
                            props: { ...option.props, defaultSelected: true },
                        }
                        : option),
                },
            };
        }
        else if (child.type === exports.RadioGroup &&
            Object.keys(config).includes(child.props.name)) {
            return {
                ...child,
                props: {
                    ...child.props,
                    children: childrenMap(child.props.children, option => option.props.value === config[child.props.name]
                        ? {
                            ...option,
                            props: { ...option.props, defaultChecked: true },
                        }
                        : option),
                },
            };
        }
        else if (child.type === exports.CheckboxGroup &&
            Object.keys(config).includes(child.props.name)) {
            return {
                ...child,
                props: {
                    ...child.props,
                    children: childrenMap(child.props.children, option => (config[child.props.name] || []).includes(option.props.value)
                        ? {
                            ...option,
                            props: { ...option.props, defaultChecked: true },
                        }
                        : option),
                },
            };
        }
        else if ((child.type === exports.TextField ||
            child.type === exports.TextArea ||
            child.type === exports.UserPicker ||
            child.type === exports.DatePicker) &&
            Object.keys(config).includes(child.props.name)) {
            return {
                ...child,
                props: {
                    ...child.props,
                    defaultValue: config[child.props.name],
                },
            };
        }
        else if (child.type === exports.Form) {
            return child;
        }
        return {
            ...child,
            props: {
                ...child.props,
                children: setConfigValues(child.props.children),
            },
        };
    });
    return _1.default.createElement(exports.Fragment, null, setConfigValues(props.children));
};
exports.Macro = (props) => {
    const { isConfig } = _2.useProductContext();
    return (_1.default.createElement(exports.Fragment, null,
        props.app,
        isConfig && _1.default.createElement(ConfigFormPrimitive, null, props.config)));
};

import { isForgeElement, isEventEffect, } from './types';
import { Macro } from './components';
import reconcilerState from './reconcilerState';
import { md2Adf } from './markdown';
export const isTextElement = (element) => element.type === 'Text';
const flatMap = (fn, items) => items.reduce((bs, a) => bs.concat(fn(a)), []);
const asyncMap = async (fn, items) => {
    const results = [];
    for (const x of items) {
        const result = await fn(x);
        results.push(result);
    }
    return results;
};
const _processAuxElement = (getUniqueName) => async (element) => {
    const { __auxId, ...props } = element.props;
    if (typeof element.type === 'string') {
        const key = getUniqueName(`${__auxId || element.type}`);
        const currentEffect = reconcilerState.currentEffect;
        if (currentEffect &&
            isEventEffect(currentEffect) &&
            key === currentEffect.handler.componentKey) {
            reconcilerState.enableSideEffectsQueue();
            await element.props[currentEffect.handler.prop](...currentEffect.args);
            reconcilerState.disableSideEffectsQueue();
        }
        return {
            element,
            key,
            hooks: [],
            currentHookIndex: 0,
            children: await asyncMap(_processAuxElement(getUniqueName), element.props.children.filter(isForgeElement)),
        };
    }
    else if (element.type === Macro) {
        if (!reconcilerState.config) {
            // set default config if no config exists
            reconcilerState.config = element.props.defaultConfig;
        }
    }
    // function component
    reconcilerState.wipFiber = {
        element,
        key: getUniqueName(`${__auxId || element.type.name}`),
        hooks: [],
        currentHookIndex: 0,
        children: [],
    };
    let children = undefined;
    while (children === undefined) {
        try {
            children = element.type(props);
        }
        catch (e) {
            if (e instanceof Promise) {
                await e;
            }
            else {
                throw e;
            }
        }
    }
    const fiber = {
        ...reconcilerState.wipFiber,
        currentHookIndex: 0,
    };
    reconcilerState.clearWipFiber();
    return {
        ...fiber,
        children: await asyncMap(_processAuxElement(getUniqueName), children ? [children] : []),
    };
};
export const processAuxElement = async (element) => {
    const visitedElements = {};
    const getUniqueName = name => {
        if (typeof visitedElements[name] === 'undefined') {
            visitedElements[name] = 0;
        }
        else {
            visitedElements[name]++;
        }
        return `${name}.${visitedElements[name]}`;
    };
    return _processAuxElement(getUniqueName)(element);
};
const overrideHandlers = (type, key) => {
    if (type === 'Button') {
        return {
            onClick: {
                componentKey: key,
                prop: 'onClick',
            },
        };
    }
    else if (type === 'Form') {
        return {
            onSubmit: {
                componentKey: key,
                prop: 'onSubmit',
            },
        };
    }
    return {};
};
export const getAuxFromFiber = (fiber) => {
    const { element, key, children } = fiber;
    /** Transform markdown to ADF
     * @see https://product-fabric.atlassian.net/wiki/spaces/AUX/pages/959122884/AUX+RFC-7+Text+rendering+pipeline
     */
    if (isTextElement(element) &&
        typeof element.type === 'string' &&
        (element.props.format === undefined || element.props.format === 'markdown')) {
        let props;
        try {
            props = {
                format: 'adf',
                content: md2Adf(element.props.content),
            };
        }
        catch (err) {
            props = {
                format: 'plaintext',
                content: `Error parsing markdown\n${err}`,
            };
        }
        return [
            {
                type: element.type,
                children: [],
                key,
                props,
            },
        ];
    }
    else if (element.type === 'ConfigForm') {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { children: _, ...props } = element.props;
        return [
            {
                children: flatMap(getAuxFromFiber, children),
                key,
                props,
                type: element.type,
            },
        ];
    }
    else if (element.type === 'Fragment') {
        return flatMap(getAuxFromFiber, children);
    }
    else if (typeof element.type === 'string') {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { children: _, ...props } = element.props;
        return [
            {
                children: flatMap(getAuxFromFiber, children),
                key,
                props: {
                    ...props,
                    ...overrideHandlers(element.type, fiber.key),
                },
                type: element.type,
            },
        ];
    }
    // function component
    return flatMap(getAuxFromFiber, children);
};
export const getStateFromFiber = (fiber) => {
    let state = {};
    if (fiber.hooks.some(hook => hook.type === 'action')) {
        state = {
            [fiber.key]: fiber.hooks.reduce((map, hook, hookIndex) => {
                if (hook.type === 'action') {
                    map[hookIndex] = hook.value;
                }
                return map;
            }, {}),
        };
    }
    fiber.children.forEach(child => {
        state = { ...state, ...getStateFromFiber(child) };
    });
    return state;
};

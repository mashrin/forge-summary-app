import reconcilerState from './reconcilerState';
import { processAuxElement, getAuxFromFiber, getStateFromFiber, } from './reconcile';
import { toProductContext } from './context';
export const render = (elem) => async (payload, runtimeContext) => {
    try {
        reconcilerState.config = payload.config;
        reconcilerState.previousState = payload.state;
        reconcilerState.productContext = toProductContext(payload.context, runtimeContext);
        let latestRenderEffect;
        const effects = [...payload.effects];
        while (effects.length !== 0) {
            const effect = effects.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion
            switch (effect.type) {
                case 'initialize':
                case 'action':
                    reconcilerState.disableSideEffectsQueue();
                    reconcilerState.clearSideEffectsQueue();
                    reconcilerState.currentEffect = effect;
                    const fiber = await processAuxElement(elem);
                    const renderEffect = {
                        type: 'render',
                        aux: { type: 'View', children: getAuxFromFiber(fiber) },
                        state: getStateFromFiber(fiber),
                    };
                    // If there are any new effects in queuedSideEffects, it means they must have been invoked from within another action.
                    // So push these into the effects queue for processing
                    effects.push(...reconcilerState.queuedSideEffects);
                    reconcilerState.previousState = renderEffect.state;
                    latestRenderEffect = renderEffect;
                    break;
                case 'event':
                    reconcilerState.disableSideEffectsQueue();
                    reconcilerState.clearSideEffectsQueue();
                    reconcilerState.currentEffect = effect;
                    await processAuxElement(elem);
                    effects.push(...reconcilerState.queuedSideEffects);
                    break;
                default:
                    throw new Error(`Invalid effect: ${JSON.stringify(effect)}`);
            }
        }
        return latestRenderEffect ? [latestRenderEffect] : [];
    }
    catch (error) {
        console.log(error);
        throw error;
    }
};

import reconcilerState from '../reconcilerState';
import { isActionEffect, isInitializeEffect } from '../types';
const getCurrentHookAndIncrementIndex = (wipFiber, value) => {
    const currentHookIndex = wipFiber.currentHookIndex;
    const componentKey = wipFiber.key;
    wipFiber.currentHookIndex++;
    // set value of hook in fiber so that it can be included in state
    wipFiber.hooks[currentHookIndex] = { type: 'action', value };
    return [
        value,
        payload => {
            reconcilerState.enqueueSideEffectIfEnabled({
                type: 'action',
                hookIndex: currentHookIndex,
                componentKey,
                payload,
            });
        },
    ];
};
const getHookValueResolver = (wipFiber, value) => {
    const currentHookIndex = wipFiber.currentHookIndex;
    wipFiber.currentHookIndex = 0;
    return Promise.resolve(value).then(value => {
        reconcilerState.disableSideEffectsQueue();
        if (!wipFiber) {
            throw new Error('cannot resolve useAction');
        }
        wipFiber.hooks[currentHookIndex] = { type: 'action', value };
    });
};
const processInitialValueAndThrow = (wipFiber, initialValue) => {
    // Don't clear the queue here, just enable it, as there may be multiple initialValue functions/promises that call dispatch.
    reconcilerState.enableSideEffectsQueue();
    // calculate the value of the hook and reset index
    const value = initialValue instanceof Function ? initialValue() : initialValue;
    const hookValueResolver = getHookValueResolver(wipFiber, value);
    wipFiber.currentHookIndex = 0;
    throw hookValueResolver;
};
export const useAction = (actionValueUpdater, initialValue) => {
    const { wipFiber, currentEffect } = reconcilerState;
    const { hooks, currentHookIndex } = wipFiber;
    if (hooks[currentHookIndex]) {
        const { value } = hooks[currentHookIndex];
        return getCurrentHookAndIncrementIndex(wipFiber, value);
    }
    const previousState = reconcilerState.previousState;
    const componentKey = wipFiber.key;
    if (isInitializeEffect(currentEffect) || !previousState[componentKey]) {
        processInitialValueAndThrow(wipFiber, initialValue);
    }
    else {
        const previousValue = previousState[componentKey][currentHookIndex];
        if (isActionEffect(currentEffect) &&
            currentEffect.componentKey === componentKey &&
            currentEffect.hookIndex === currentHookIndex) {
            reconcilerState.enableSideEffectsQueue();
            // if the action refers to this hook, run previous state through action value updater
            const value = actionValueUpdater(previousValue, currentEffect.payload);
            throw getHookValueResolver(wipFiber, value);
        }
        return getCurrentHookAndIncrementIndex(wipFiber, previousValue);
    }
    throw new Error('invalid effect');
};

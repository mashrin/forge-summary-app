import { __assign, __extends, __read, __spread, __values } from "tslib";
import { Step, StepMap, StepResult, Transform, } from 'prosemirror-transform';
import { cellsAtColumn } from './utils/cells-at-column';
import { findColumn } from './utils/find-column';
import { getTableRectFromDoc } from './utils/get-table-rect-from-doc';
import { applyCellStep, createCellStep, getMapFromCellStep, invertCellStep, } from './utils/cell-step';
import { SideEffectsHandler } from './utils/side-effects/side-effects';
import memoizeOne from 'memoize-one';
var ADD_COLUMN_STEP = 'ak-add-column';
function printColumnInfo(columnInfo) {
    var e_1, _a;
    var cellsFrom = [];
    try {
        for (var _b = __values(columnInfo.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var cellInfo = _c.value;
            cellsFrom.push(cellInfo.from);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return "[" + cellsFrom.join(',') + "]";
}
function createColumnInfo(cellsInfo) {
    return new Map(cellsInfo.map(function (cellInfo) { return [cellInfo.from, cellInfo]; }));
}
var getTableRectAndColumnFactory = function (doc, pos, columnInfo) {
    return memoizeOne(function () {
        var rect = getTableRectFromDoc(doc, pos);
        var column = findColumn(columnInfo, rect);
        if (column === null) {
            throw new Error('no column');
        }
        return {
            rect: rect,
            column: column,
        };
    });
};
/**
 * Index and positions looks like
 * 0    1    2    3   -> Add Column Index
 * | 5  | 10 | 15 |   -> Table with Positions
 * | 20 | 25 | 30 |
 * 0    1    2    x   -> Remove Column Index
 *
 */
var AddColumnStep = /** @class */ (function (_super) {
    __extends(AddColumnStep, _super);
    function AddColumnStep(tablePos, addColumnStepInfo, isDelete) {
        if (isDelete === void 0) { isDelete = false; }
        var _this = _super.call(this) || this;
        _this.tablePos = tablePos;
        _this.isDelete = isDelete;
        _this.sideEffectsHandler = new SideEffectsHandler(addColumnStepInfo.sideEffects);
        _this.columnInfo = createColumnInfo(addColumnStepInfo.cells);
        return _this;
    }
    /**
     * Detect the column based on all the cells step in column info.
     * Recreate columnInfo based on the current document. We might need to add new cells added by insert row or unmerge cells.
     * If isDelete
     *    Decrease colspan if one row has merged cell
     *    Remove all the cells using columnInfo.cellStep[].from
     * else
     *    Increase colspan if one row had merged cell
     *    Add all new cells at columnInfo.cellStep[].from,
     *      if there is columnInfo.cellStep[].newCell use it
     *      else create an empty cell
     *
     * @param doc Current document
     */
    AddColumnStep.prototype.apply = function (doc) {
        var tablePos = this.tablePos;
        // Create transform base on the doc
        var tr = new Transform(doc);
        if (this.sideEffectsHandler.table.handleAddTable(tr, this.isDelete)) {
            return StepResult.ok(tr.doc);
        }
        var tableRect;
        try {
            tableRect = getTableRectFromDoc(doc, tablePos);
        }
        catch (e) {
            return StepResult.fail(e.message);
        }
        var column = findColumn(this.columnInfo, tableRect);
        if (column === null) {
            return StepResult.fail("No column for this cells \"" + printColumnInfo(this.columnInfo) + "\" in table at position \"" + tablePos + "\".");
        }
        if (this.sideEffectsHandler.table.handleRemoveTable(tr, this.tablePos, tableRect, column, this.isDelete)) {
            return StepResult.ok(tr.doc);
        }
        this.columnInfo = this.applyCellSteps(tr, tableRect, column, this.isDelete);
        // Return the document modified.
        return StepResult.ok(tr.doc);
    };
    /**
     * Update tablePos with the new position. If tablePos doesnt exist any more remove the step
     * Update all the cellStep inside columnInfo. If cellStep.from position gets deleted removed it from column info
     * if cellStep.length === 0 remove the step
     * Create a new step with all the position updated
     * @param mapping
     */
    AddColumnStep.prototype.map = function (mapping) {
        var e_2, _a;
        var tablePosResult = mapping.mapResult(this.tablePos);
        if (tablePosResult.deleted) {
            // If table was deleted remove the step
            return null;
        }
        var cellSteps = [];
        try {
            for (var _b = __values(this.columnInfo.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var oldCellStep = _c.value;
                var fromResult = mapping.mapResult(oldCellStep.from);
                var toResult = mapping.mapResult(oldCellStep.to);
                if (fromResult.deleted && toResult.deleted)
                    continue;
                var cellStep = __assign(__assign({}, oldCellStep), { from: fromResult.pos, to: toResult.pos });
                if (oldCellStep.mergeWith !== undefined) {
                    cellStep.mergeWith = mapping.map(oldCellStep.mergeWith);
                }
                cellSteps.push(cellStep);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (cellSteps.length === 0) {
            return null;
        }
        var sideEffects = this.sideEffectsHandler.map(mapping);
        return new AddColumnStep(tablePosResult.pos, { cells: cellSteps, sideEffects: sideEffects }, this.isDelete);
    };
    /**
     * if isDelete
     *    Get the original cell node at columnInfo.cellStep[].from to columnInfo.cellStep[].to
     *    Create a copy of the node
     *    Create a new cellStep with the same positions but with the clone node as a content
     *    return new step inverted
     * else
     *    Remove the content from each columnInfo.cellStep[].content
     *    return new step inverted
     * @param originalDoc
     */
    AddColumnStep.prototype.invert = function (originalDoc) {
        var _this = this;
        var stepMap = this.getMap();
        // Memoize function to be called only on delete scenarios
        var getTableRectAndColumn = getTableRectAndColumnFactory(originalDoc, this.tablePos, this.columnInfo);
        // This is needed because the real pos of the cell in the generated document is affected by the previous operations.
        var newCellSteps = Array.from(this.columnInfo.values(), function (oldCellStep) {
            var newCellStep = invertCellStep(originalDoc, getTableRectAndColumn, oldCellStep, _this.isDelete, stepMap);
            return newCellStep;
        });
        var sideEffects = this.sideEffectsHandler.invert(originalDoc, this.isDelete, stepMap);
        return new AddColumnStep(this.tablePos, { cells: newCellSteps, sideEffects: sideEffects }, !this.isDelete);
    };
    /**
     * StepMap is created based on columnInfo.
     * ColumnInfo is created on constructor and once is applied (the document could have new cells that weren't part of the original set)
     * if isDelete
     *    Create range array based on cell info where each range is [cellStep.from, cellStep.from - cellStep.to, 0]
     * else
     *    Create range array base on cell info where each range is [cellStep.from, 0, cellStep.content ? cellStep.content.nodeSize : defaultEmptyCellNodeSize]
     *
     * Ranges in ProseMirror are represented by each 3 elements in an array.
     * As [pos, currentSize, newSize, pos2, currentSize2, newSize2] where:
     * pos: Position in the document
     * currentSize: Represent the affected range, this will be pos + currentSize
     * newSize: Represent the new values, pos + newSize
     */
    AddColumnStep.prototype.getMap = function () {
        var e_3, _a;
        var tableMap = this.sideEffectsHandler.getTableMap(this.isDelete);
        if (tableMap) {
            return tableMap;
        }
        var ranges = [];
        try {
            for (var _b = __values(this.columnInfo.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var cellStep = _c.value;
                ranges.push.apply(ranges, __spread(getMapFromCellStep(cellStep, this.isDelete)));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        ranges = this.sideEffectsHandler.rows.addRowRanges(ranges, this.isDelete);
        // If no steps, I create am empty stepMap
        return new StepMap(ranges);
    };
    /**
     * Try to merge this step with another one, to be applied directly
     * after it. Returns the merged step when possible, null if the
     * steps can't be merged.
     */
    AddColumnStep.prototype.merge = function (other) {
        // We cannot merge add column step at the moment
        return null;
    };
    /**
     * Create a JSON-serializeable representation of this step. When
     * defining this for a custom subclass, make sure the result object
     * includes the step type's [JSON id](#transform.Step^jsonID) under
     * the `stepType` property.
     */
    AddColumnStep.prototype.toJSON = function () {
        var addColumnStepJson = {
            stepType: ADD_COLUMN_STEP,
            tablePos: this.tablePos,
            cells: Array.from(this.columnInfo.values(), function (cellStep) {
                var cellStepJson = {
                    from: cellStep.from,
                    to: cellStep.to,
                };
                if (cellStep.mergeWith !== undefined) {
                    cellStepJson.mergeWith = cellStep.mergeWith;
                }
                if (cellStep.newCell !== undefined) {
                    cellStepJson.newCell = cellStep.newCell.toJSON();
                }
                return cellStepJson;
            }),
            isDelete: this.isDelete,
        };
        var sideEffectsJSON = this.sideEffectsHandler.toJSON();
        if (sideEffectsJSON) {
            addColumnStepJson.sideEffects = sideEffectsJSON;
        }
        return addColumnStepJson;
    };
    /**
     * Deserialize a step from its JSON representation. Will call
     * through to the step class' own implementation of this method.
     */
    AddColumnStep.fromJSON = function (schema, json) {
        // TODO: Add validation. Return null if it is invalid. Check in review if this is necessary
        var cells = json.cells.map(function (cellsJson) {
            var cell = __assign(__assign({}, cellsJson), { newCell: cellsJson.newCell
                    ? schema.nodeFromJSON(cellsJson.newCell)
                    : undefined });
            return cell;
        });
        var sideEffects;
        if (json.sideEffects) {
            sideEffects = SideEffectsHandler.fromJSON(schema, json.sideEffects);
        }
        return new AddColumnStep(json.tablePos, { cells: cells, sideEffects: sideEffects }, json.isDelete);
    };
    AddColumnStep.create = function (doc, tablePos, column, isDelete) {
        if (isDelete === void 0) { isDelete = false; }
        var tableRect = getTableRectFromDoc(doc, tablePos);
        // By default add column will rely on default behaviour (add empty cell).
        // There is no need to add content
        var cells = [];
        var iter = cellsAtColumn(tableRect, column);
        var next = iter.next();
        while (!next.done) {
            var cell = next.value;
            cells.push(createCellStep(cell, column, isDelete));
            var skipRows = 0;
            if (cell.attrs && cell.attrs.rowspan) {
                skipRows = cell.attrs.rowspan - 1;
            }
            next = iter.next(skipRows);
        }
        return new AddColumnStep(tablePos, { cells: cells }, isDelete);
    };
    AddColumnStep.prototype.applyCellSteps = function (tr, tableRect, column, isDelete) {
        var newColumnInfo = new Map();
        var rowsHandler = this.sideEffectsHandler.rows.start(this.isDelete);
        var iter = cellsAtColumn(tableRect, column);
        var next = iter.next();
        // Iterate for all the cells in the current document
        while (!next.done) {
            var cell = next.value;
            var previousCellStep = this.columnInfo.get(cell.from);
            var newCellStep = createCellStep(cell, column, isDelete, previousCellStep);
            // If is the last cell in the row and doesnt have colspan I need to remove the whole row.
            var removeRowResult = rowsHandler.handle(tr, tableRect, cell.row, column, cell);
            if (removeRowResult.handled) {
                next = iter.next(removeRowResult.skipRows);
                continue;
            }
            // Apply the step, to the pseudo document, get rows to skip, and the cellstep (might be modified, for example, a merge cell that remove the cell instead)
            var _a = applyCellStep(tr, tableRect, cell, newCellStep, isDelete, column), skipRows = _a.skipRows, cellStep = _a.cellStep;
            // Store the new cell step. This could be an existing one or a new cell.
            newColumnInfo.set(newCellStep.from, cellStep);
            next = iter.next(skipRows);
        }
        rowsHandler.end(tr, tableRect, column);
        return newColumnInfo;
    };
    return AddColumnStep;
}(Step));
export { AddColumnStep };
Step.jsonID(ADD_COLUMN_STEP, AddColumnStep);
//# sourceMappingURL=add-column.js.map
import { Node as ProseMirrorNode, Schema } from 'prosemirror-model';
import { Mappable, Step, StepMap, StepResult } from 'prosemirror-transform';
import { AddColumnStepInfo, AddColumnStepJson } from './types';
/**
 * Index and positions looks like
 * 0    1    2    3   -> Add Column Index
 * | 5  | 10 | 15 |   -> Table with Positions
 * | 20 | 25 | 30 |
 * 0    1    2    x   -> Remove Column Index
 *
 */
export declare class AddColumnStep<S extends Schema = any> extends Step {
    private readonly tablePos;
    private readonly isDelete;
    private columnInfo;
    private sideEffectsHandler;
    constructor(tablePos: number, addColumnStepInfo: AddColumnStepInfo, isDelete?: boolean);
    /**
     * Detect the column based on all the cells step in column info.
     * Recreate columnInfo based on the current document. We might need to add new cells added by insert row or unmerge cells.
     * If isDelete
     *    Decrease colspan if one row has merged cell
     *    Remove all the cells using columnInfo.cellStep[].from
     * else
     *    Increase colspan if one row had merged cell
     *    Add all new cells at columnInfo.cellStep[].from,
     *      if there is columnInfo.cellStep[].newCell use it
     *      else create an empty cell
     *
     * @param doc Current document
     */
    apply(doc: ProseMirrorNode<S>): StepResult<S>;
    /**
     * Update tablePos with the new position. If tablePos doesnt exist any more remove the step
     * Update all the cellStep inside columnInfo. If cellStep.from position gets deleted removed it from column info
     * if cellStep.length === 0 remove the step
     * Create a new step with all the position updated
     * @param mapping
     */
    map(mapping: Mappable): Step<S> | null | undefined;
    /**
     * if isDelete
     *    Get the original cell node at columnInfo.cellStep[].from to columnInfo.cellStep[].to
     *    Create a copy of the node
     *    Create a new cellStep with the same positions but with the clone node as a content
     *    return new step inverted
     * else
     *    Remove the content from each columnInfo.cellStep[].content
     *    return new step inverted
     * @param originalDoc
     */
    invert(originalDoc: ProseMirrorNode<S>): Step<S>;
    /**
     * StepMap is created based on columnInfo.
     * ColumnInfo is created on constructor and once is applied (the document could have new cells that weren't part of the original set)
     * if isDelete
     *    Create range array based on cell info where each range is [cellStep.from, cellStep.from - cellStep.to, 0]
     * else
     *    Create range array base on cell info where each range is [cellStep.from, 0, cellStep.content ? cellStep.content.nodeSize : defaultEmptyCellNodeSize]
     *
     * Ranges in ProseMirror are represented by each 3 elements in an array.
     * As [pos, currentSize, newSize, pos2, currentSize2, newSize2] where:
     * pos: Position in the document
     * currentSize: Represent the affected range, this will be pos + currentSize
     * newSize: Represent the new values, pos + newSize
     */
    getMap(): StepMap;
    /**
     * Try to merge this step with another one, to be applied directly
     * after it. Returns the merged step when possible, null if the
     * steps can't be merged.
     */
    merge(other: Step<S>): Step<S> | null | undefined;
    /**
     * Create a JSON-serializeable representation of this step. When
     * defining this for a custom subclass, make sure the result object
     * includes the step type's [JSON id](#transform.Step^jsonID) under
     * the `stepType` property.
     */
    toJSON(): AddColumnStepJson;
    /**
     * Deserialize a step from its JSON representation. Will call
     * through to the step class' own implementation of this method.
     */
    static fromJSON<S extends Schema = any>(schema: S, json: AddColumnStepJson): Step<S>;
    static create(doc: ProseMirrorNode, tablePos: number, column: number, isDelete?: boolean): AddColumnStep<any>;
    private applyCellSteps;
}

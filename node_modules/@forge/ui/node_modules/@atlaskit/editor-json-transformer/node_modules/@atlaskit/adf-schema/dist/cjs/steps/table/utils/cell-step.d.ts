import { Node as ProseMirrorNode } from 'prosemirror-model';
import { Cell } from './cells-at-column';
import { CellStep } from '../types';
import { Transform, StepMap } from 'prosemirror-transform';
import { TableRect } from 'prosemirror-tables';
/**
 * Given a cell step, this function has to do the specific transformation to executed that step.
 * It returns the applied cellStep and rows that needs to skip (because it was already handled).
 * @param tr
 * @param tableRect
 * @param cell
 * @param cellStep
 * @param isDelete
 * @param column
 */
export declare function applyCellStep(tr: Transform, tableRect: TableRect, cell: Cell, cellStep: CellStep, isDelete: boolean, column: number): {
    tr: Transform;
    skipRows: number;
    cellStep: CellStep;
};
/**
 * Given a cell step, this functions return un StepMap representing this action.
 * [position, oldSize, newSize]
 * @param cellStep
 * @param isDelete
 */
export declare function getMapFromCellStep(cellStep: CellStep, isDelete: boolean): [number, number, number];
/**
 * Given a cell step, this function invert that step.
 * @param doc
 * @param getTableRectAndColumn
 * @param cellStep
 * @param isDelete
 * @param stepMap
 */
export declare function invertCellStep(doc: ProseMirrorNode, getTableRectAndColumn: () => {
    rect: TableRect;
    column: number;
}, cellStep: CellStep, isDelete: boolean, stepMap: StepMap): CellStep;
/**
 * Create a cell step based on the current cell and operation (add/delete)
 * @param cell
 * @param column
 * @param isDelete
 * @param previousCellStep
 */
export declare function createCellStep(cell: Cell, column: number, isDelete: boolean, previousCellStep?: CellStep): CellStep;

import { __generator } from "tslib";
import { columnIsHeader, tableNodeTypes } from 'prosemirror-tables';
import { getCellIndex, hasMergedColumns, isRootRow } from './table-map';
/**
 * Helper to have a consistent way to iterate for all the cells in a column.
 * You can skip rows by passing the rows to skipped in the next arguments.
 * For example: `iter.next(1)` to skip the next row
 * @param rect
 * @param col
 */
export function cellsAtColumn(rect, col) {
    var map, tableStart, table, refColumn, row, index, pos, hasMergedCells, type, cell, cellInfo, skippedRows;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                map = rect.map, tableStart = rect.tableStart, table = rect.table;
                refColumn = col > 0 ? -1 : 0;
                if (columnIsHeader(map, table, col + refColumn))
                    refColumn = col === 0 || col === map.width ? null : 0;
                row = 0;
                _a.label = 1;
            case 1:
                if (!(row < map.height)) return [3 /*break*/, 4];
                index = getCellIndex(rect.map, row, col);
                pos = map.map[index];
                hasMergedCells = hasMergedColumns(rect.map, row, col) && isRootRow(rect.map, row, col);
                type = refColumn == null
                    ? tableNodeTypes(table.type.schema).cell
                    : table.nodeAt(map.map[index + refColumn]).type;
                if (!hasMergedCells) {
                    pos = map.positionAt(row, col, table);
                }
                cell = table.nodeAt(pos);
                cellInfo = {
                    from: tableStart + pos,
                    to: tableStart + pos,
                    row: row,
                    col: hasMergedCells ? map.colCount(pos) : col,
                    type: type,
                    hasMergedCells: hasMergedCells,
                };
                if (cell) {
                    cellInfo.attrs = cell.attrs;
                    cellInfo.to = tableStart + pos + cell.nodeSize;
                }
                return [4 /*yield*/, cellInfo];
            case 2:
                skippedRows = _a.sent();
                if (skippedRows && skippedRows > 0) {
                    row += skippedRows;
                }
                _a.label = 3;
            case 3:
                row++;
                return [3 /*break*/, 1];
            case 4: return [2 /*return*/];
        }
    });
}
//# sourceMappingURL=cells-at-column.js.map
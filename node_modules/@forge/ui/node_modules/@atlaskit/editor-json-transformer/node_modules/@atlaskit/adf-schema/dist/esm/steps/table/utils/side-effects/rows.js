import { __assign, __read, __spread, __values } from "tslib";
import { hasMergedColumns } from '../table-map';
function mergedRanges(first, second) {
    var newRanges = [];
    var firstLength = first.length;
    var secondLength = second.length;
    var i = 0;
    var j = 0;
    while (i < firstLength && j < secondLength) {
        if (first[i] < second[j]) {
            newRanges.push(first[i], first[i + 1], first[i + 2]);
            i += 3;
        }
        else {
            newRanges.push(second[j], second[j + 1], second[j + 2]);
            j += 3;
        }
    }
    if (i < firstLength) {
        newRanges.push.apply(newRanges, __spread(first.slice(i)));
    }
    if (j < secondLength) {
        newRanges.push.apply(newRanges, __spread(second.slice(i)));
    }
    return newRanges;
}
function increaseRowSpan(tr, rect, row) {
    var map = rect.map, tableStart = rect.tableStart;
    for (var col = 0; col < map.width; col++) {
        var index = row * map.width + col;
        var pos = map.map[index];
        var mappedPos = tr.mapping.map(pos + tableStart);
        var attrs = tr.doc.nodeAt(mappedPos).attrs;
        tr.setNodeMarkup(mappedPos, undefined, __assign(__assign({}, attrs), { rowspan: attrs.rowspan + 1 }));
        col += attrs.colspan - 1;
    }
}
function decreaseRowspan(tr, rect, row, colToRemove) {
    var skipRows = 0;
    var map = rect.map, table = rect.table, tableStart = rect.tableStart;
    for (var col = 0; col < map.width; col++) {
        var index = row * map.width + col;
        var pos = map.map[index];
        if (row > 0 && pos === map.map[index - map.width]) {
            // If this cell starts in the row above, simply reduce its rowspan
            var mappedPos = tr.mapping.map(pos + tableStart);
            var attrs = tr.doc.nodeAt(mappedPos).attrs;
            tr.setNodeMarkup(mappedPos, undefined, __assign(__assign({}, attrs), { rowspan: attrs.rowspan - 1 }));
            col += attrs.colspan - 1;
        }
        else if (col === colToRemove) {
            skipRows = table.nodeAt(pos).attrs.rowspan - 1;
        }
    }
    return skipRows;
}
function isLastCellInRow(rect, row, col) {
    var rowNode = rect.table.child(row);
    if (!rowNode) {
        return false;
    }
    return rowNode.childCount === 1 && !hasMergedColumns(rect.map, row, col);
}
function removeRowWithLastCell(tr, rect, row, _col) {
    // Get row pos
    var from = rect.tableStart;
    for (var i = 0; i < row; i++)
        from += rect.table.child(i).nodeSize;
    var rowNode = rect.table.child(row);
    var to = from + rowNode.nodeSize;
    // Create sideEffect and delete the row
    // We store original row position before modifications
    tr.delete(tr.mapping.map(from), tr.mapping.map(to));
    // Change rowspan of all cells except current col and get the rows to skip
    var skipRows = decreaseRowspan(tr, rect, row, _col);
    return {
        skipRows: skipRows,
        row: {
            from: from,
            to: to,
            rowNode: rowNode.copy(rowNode.content),
        },
    };
}
function addRow(tr, rect, prevRow, rowSideEffect) {
    var cellNode = rowSideEffect.rowNode.child(0);
    tr.insert(tr.mapping.map(rowSideEffect.from), rowSideEffect.rowNode);
    increaseRowSpan(tr, rect, prevRow);
    return cellNode.attrs.rowspan - 1;
}
var RowsSideEffectHandler = /** @class */ (function () {
    function RowsSideEffectHandler(rowsSideEffect) {
        var _this = this;
        this.deleteHandler = function () {
            var newRows = [];
            return {
                handle: function (tr, rect, row, col, cell) {
                    if (!isLastCellInRow(rect, row, col)) {
                        return {
                            handled: false,
                        };
                    }
                    var _a = removeRowWithLastCell(tr, rect, row, col), rowSideEffect = _a.row, skipRows = _a.skipRows;
                    newRows.push(rowSideEffect);
                    return { handled: true, skipRows: skipRows };
                },
                end: function () {
                    if (newRows.length > 0) {
                        _this.rows = newRows;
                    }
                    else {
                        _this.rows = undefined;
                    }
                },
            };
        };
        this.addHandler = function () {
            var lastCellFrom = 0;
            var i = 0;
            return {
                handle: function (tr, rect, row, col, cell) {
                    // // If not sideEffects stored return;
                    if (!_this.rows || i >= _this.rows.length) {
                        return { handled: false };
                    }
                    // Next row to add;
                    var skipRows;
                    var nextRow;
                    while ((nextRow = _this.rows[i]) &&
                        nextRow.from > lastCellFrom &&
                        nextRow.from < cell.from) {
                        // I am in between of the previous and next row in the table;
                        skipRows = addRow(tr, rect, row - 1, nextRow);
                        i++;
                    }
                    lastCellFrom = cell.from;
                    if (!skipRows || skipRows === 0) {
                        return { handled: false };
                    }
                    return {
                        handled: true,
                        skipRows: skipRows - 1,
                    };
                },
                end: function (tr, rect, col) {
                    if (!_this.rows || i >= _this.rows.length) {
                        return;
                    }
                    // Add rows at the end of the table
                    var nextRow;
                    while ((nextRow = _this.rows[i])) {
                        addRow(tr, rect, rect.map.height - 1, nextRow);
                        i++;
                    }
                },
            };
        };
        this.rows = rowsSideEffect;
    }
    RowsSideEffectHandler.prototype.start = function (isDelete) {
        if (isDelete) {
            return this.deleteHandler();
        }
        return this.addHandler();
    };
    RowsSideEffectHandler.prototype.addRowRanges = function (ranges, isDelete) {
        var e_1, _a;
        if (!this.rows) {
            return ranges;
        }
        var rowRanges = [];
        try {
            for (var _b = __values(this.rows), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                var from = row.from, to = row.to;
                if (isDelete) {
                    rowRanges.push(from, to - from, 0);
                }
                else {
                    rowRanges.push(from, 0, to - from);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Merged ranges
        return mergedRanges(ranges, rowRanges);
    };
    RowsSideEffectHandler.prototype.map = function (mapping) {
        return [];
    };
    RowsSideEffectHandler.prototype.invert = function (originalDoc, isDelete, map) {
        var e_2, _a;
        if (!this.rows) {
            return;
        }
        var invertedRows = [];
        try {
            for (var _b = __values(this.rows), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                if (isDelete) {
                    // Moving from delete to add keep the inverted rows + offset
                    var offset = map.map(row.from) - row.from;
                    invertedRows.push(__assign(__assign({}, row), { from: row.from + offset, to: row.from + offset }));
                }
                else {
                    // Moving from add to delete keep
                    // TODO: I think we need to add the respective cell into the cellSteps...... not sure....
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return invertedRows;
    };
    RowsSideEffectHandler.prototype.toJSON = function () {
        var e_3, _a;
        if (!this.rows) {
            return;
        }
        var rowsInJson = [];
        try {
            for (var _b = __values(this.rows), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                rowsInJson.push({
                    from: row.from,
                    to: row.to,
                    rowNode: row.rowNode.toJSON(),
                });
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return rowsInJson;
    };
    RowsSideEffectHandler.fromJSON = function (schema, json) {
        var e_4, _a;
        var rowSideEffects = [];
        try {
            for (var json_1 = __values(json), json_1_1 = json_1.next(); !json_1_1.done; json_1_1 = json_1.next()) {
                var row = json_1_1.value;
                rowSideEffects.push({
                    from: row.from,
                    to: row.to,
                    rowNode: schema.nodeFromJSON(row.rowNode),
                });
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (json_1_1 && !json_1_1.done && (_a = json_1.return)) _a.call(json_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return rowSideEffects;
    };
    return RowsSideEffectHandler;
}());
export { RowsSideEffectHandler };
//# sourceMappingURL=rows.js.map
import { columnIsHeader, tableNodeTypes } from 'prosemirror-tables';
import { getCellIndex, hasMergedColumns, isRootRow } from './table-map';
/**
 * Helper to have a consistent way to iterate for all the cells in a column.
 * You can skip rows by passing the rows to skipped in the next arguments.
 * For example: `iter.next(1)` to skip the next row
 * @param rect
 * @param col
 */
export function* cellsAtColumn(rect, col) {
    const { map, tableStart, table } = rect;
    let refColumn = col > 0 ? -1 : 0;
    if (columnIsHeader(map, table, col + refColumn))
        refColumn = col === 0 || col === map.width ? null : 0;
    for (let row = 0; row < map.height; row++) {
        let index = getCellIndex(rect.map, row, col);
        let pos = map.map[index];
        // We only consider to has merged cell to the first cell in a rowspan.
        const hasMergedCells = hasMergedColumns(rect.map, row, col) && isRootRow(rect.map, row, col);
        // If this position falls inside a col-spanning cell
        let type = refColumn == null
            ? tableNodeTypes(table.type.schema).cell
            : table.nodeAt(map.map[index + refColumn]).type;
        if (!hasMergedCells) {
            pos = map.positionAt(row, col, table);
        }
        let cell = table.nodeAt(pos);
        const cellInfo = {
            from: tableStart + pos,
            to: tableStart + pos,
            row,
            col: hasMergedCells ? map.colCount(pos) : col,
            type,
            hasMergedCells,
        };
        if (cell) {
            cellInfo.attrs = cell.attrs;
            cellInfo.to = tableStart + pos + cell.nodeSize;
        }
        // We let the consumer to pass the rows that we want to skip
        const skippedRows = yield cellInfo;
        if (skippedRows && skippedRows > 0) {
            row += skippedRows;
        }
    }
}
//# sourceMappingURL=cells-at-column.js.map